<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>hClustering: string_utils Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">hClustering
   &#160;<span id="projectnumber">2.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">string_utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a7d3311ef9559a1b5e6fdef079b28cb47">toString</a> (const T &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a7058154de83b4b508107b4ef172f2b8f">fromString</a> (const std::string &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a7361b7aeffdaecd0ee490f6f12796339">rTrim</a> (const std::string &amp;source, const std::string &amp;t=<a class="el" href="namespacestring__utils.html#a716c3d0cc1ab19bd56d1b2aa2a50662f">WHITESPACE</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a7e604334a4cdd40e0837691c6ce5164e">lTrim</a> (const std::string &amp;source, const std::string &amp;t=<a class="el" href="namespacestring__utils.html#a716c3d0cc1ab19bd56d1b2aa2a50662f">WHITESPACE</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a63713e559707c9cc927d62729fe424c9">trim</a> (const std::string &amp;source, const std::string &amp;t=<a class="el" href="namespacestring__utils.html#a716c3d0cc1ab19bd56d1b2aa2a50662f">WHITESPACE</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a4a692eb62e01ecc0757df7d2f53d3f36">toUpper</a> (const std::string &amp;source)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a213604a8351148a005bb3bea470358e1">toLower</a> (const std::string &amp;source)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a535b9b20922e895321420967d2030116">tokenize</a> (const std::string &amp;source, const std::string &amp;delim=<a class="el" href="namespacestring__utils.html#a716c3d0cc1ab19bd56d1b2aa2a50662f">WHITESPACE</a>, bool compress=true)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a2bb23cf681e96a435cf42db0f0faa727">operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a54c6f86a6eb63870ef09e19e7da103f3">operator&gt;&gt;</a> (std::istream &amp;in, std::vector&lt; T &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a8fc49064166e7829fe1c2ff5d4921e5f">operator&lt;&lt;</a> (std::ostream &amp;os, const std::list&lt; T &gt; &amp;l)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a290aeee844eb37e1c76a23243d5d8ee2">operator&lt;&lt;</a> (std::ostream &amp;os, const std::set&lt; T &gt; &amp;s)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__utils.html#a716c3d0cc1ab19bd56d1b2aa2a50662f">WHITESPACE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These characters are regarded as whitespaces.  <a href="#a716c3d0cc1ab19bd56d1b2aa2a50662f"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Some utilities for string manipulation and output operations. Please note that the overloaded ostream output operators aren't in a separate namespace but the string manipulation functions. This is because of short use of e.g. the <code>&lt;&lt;</code> operator instead of <code>string_utils::operator( cout, myVector)</code>.</p>
<p>The reason for not using the Boost trimming functions is, that Boost providing just Whitespace trimming depending on the current locale, but we might want to trim other character sets too.</p>
<p>The reason for not using the Boost case switching functions is that we want those functions to return a <code>std::string</code> copy which is modified to make some call chains ala: <code>foo( rTrim( toLower( str ), "bar" ) );</code>.</p>
<p>The reason for not using Boosts Tokenizer is, that this tokenizer, is much most simplest to use :). </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a7058154de83b4b508107b4ef172f2b8f"></a><!-- doxytag: member="string_utils::fromString" ref="a7058154de83b4b508107b4ef172f2b8f" args="(const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespacestring__utils.html#a7058154de83b4b508107b4ef172f2b8f">string_utils::fromString</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a given string to a value of a certain type. The target type must provide a operator&gt;&gt; to work or be a standard scalar type.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the source type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the value to cast to string</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e604334a4cdd40e0837691c6ce5164e"></a><!-- doxytag: member="string_utils::lTrim" ref="a7e604334a4cdd40e0837691c6ce5164e" args="(const std::string &amp;source, const std::string &amp;t=WHITESPACE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespacestring__utils.html#a7e604334a4cdd40e0837691c6ce5164e">string_utils::lTrim</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code>WHITESPACE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Trims any occurence of each character given in parameter t from the start (or left side) of the given string.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>String to trim </td></tr>
    <tr><td class="paramname">t</td><td>String representing a set containg all trimmable characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the trimmed string </dd></dl>

</div>
</div>
<a class="anchor" id="a2bb23cf681e96a435cf42db0f0faa727"></a><!-- doxytag: member="string_utils::operator&lt;&lt;" ref="a2bb23cf681e96a435cf42db0f0faa727" args="(std::ostream &amp;os, const std::vector&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; string_utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes every vector to an output stream such as cout, if its elements have an output operator defined.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream where the elements are written to </td></tr>
    <tr><td class="paramname">v</td><td>Vector containing the elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The output stream again. </dd></dl>

</div>
</div>
<a class="anchor" id="a8fc49064166e7829fe1c2ff5d4921e5f"></a><!-- doxytag: member="string_utils::operator&lt;&lt;" ref="a8fc49064166e7829fe1c2ff5d4921e5f" args="(std::ostream &amp;os, const std::list&lt; T &gt; &amp;l)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; string_utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes every list to an output stream such as cout, if its elements have an output operator defined.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream where the elements are written to </td></tr>
    <tr><td class="paramname">l</td><td>List containing the elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The output stream again. </dd></dl>

</div>
</div>
<a class="anchor" id="a290aeee844eb37e1c76a23243d5d8ee2"></a><!-- doxytag: member="string_utils::operator&lt;&lt;" ref="a290aeee844eb37e1c76a23243d5d8ee2" args="(std::ostream &amp;os, const std::set&lt; T &gt; &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; string_utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes every set to an output stream such as cout, if its elements have an output operator defined.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream where the elements are written to </td></tr>
    <tr><td class="paramname">s</td><td>set containing the elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The output stream again. </dd></dl>

</div>
</div>
<a class="anchor" id="a54c6f86a6eb63870ef09e19e7da103f3"></a><!-- doxytag: member="string_utils::operator&gt;&gt;" ref="a54c6f86a6eb63870ef09e19e7da103f3" args="(std::istream &amp;in, std::vector&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; string_utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write an input stream into the given vector. The delimiter is implicitly set to ", ". Also wrapping brackets '[' ']' are expected. In general this is the opposite of the output operator above. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The inputstream is first written into a string then the convertion into T via fromString takes place. </dd>
<dd>
The delimiter should not be in an elements string representation since then the tokenizer may gets confused</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input stream </td></tr>
    <tr><td class="paramname">v</td><td>Vector where to store the elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The input stream again </dd></dl>

</div>
</div>
<a class="anchor" id="a7361b7aeffdaecd0ee490f6f12796339"></a><!-- doxytag: member="string_utils::rTrim" ref="a7361b7aeffdaecd0ee490f6f12796339" args="(const std::string &amp;source, const std::string &amp;t=WHITESPACE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespacestring__utils.html#a7361b7aeffdaecd0ee490f6f12796339">string_utils::rTrim</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code>WHITESPACE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Trims any occurence of each character given in parameter t from the end (or right side) of the given string.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>String to trim </td></tr>
    <tr><td class="paramname">t</td><td>String representing a set containg all trimmable characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the trimmed string </dd></dl>

</div>
</div>
<a class="anchor" id="a535b9b20922e895321420967d2030116"></a><!-- doxytag: member="string_utils::tokenize" ref="a535b9b20922e895321420967d2030116" args="(const std::string &amp;source, const std::string &amp;delim=WHITESPACE, bool compress=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; <a class="el" href="namespacestring__utils.html#a535b9b20922e895321420967d2030116">string_utils::tokenize</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em> = <code>WHITESPACE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compress</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Splits the given string into a vector of strings (so called tokens).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>String to tokenize </td></tr>
    <tr><td class="paramname">compress</td><td>If true, charactes matching between two tokens are collapsed and handled as just one character. </td></tr>
    <tr><td class="paramname">delim</td><td>String representing a set containg all characters considered as whitespace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of strings containing the tokens. </dd></dl>

</div>
</div>
<a class="anchor" id="a213604a8351148a005bb3bea470358e1"></a><!-- doxytag: member="string_utils::toLower" ref="a213604a8351148a005bb3bea470358e1" args="(const std::string &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespacestring__utils.html#a213604a8351148a005bb3bea470358e1">string_utils::toLower</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transforms all characters in the given string into lower case characters.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>String to transpose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the lower case only string </dd></dl>

</div>
</div>
<a class="anchor" id="a7d3311ef9559a1b5e6fdef079b28cb47"></a><!-- doxytag: member="string_utils::toString" ref="a7d3311ef9559a1b5e6fdef079b28cb47" args="(const T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespacestring__utils.html#a7d3311ef9559a1b5e6fdef079b28cb47">string_utils::toString</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a given value to a string. The input value must provide a operator&lt;&lt; or be a standard scalar type.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the source type. You do not need to specify this directly as it can be deducted from the given parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to cast to string</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a692eb62e01ecc0757df7d2f53d3f36"></a><!-- doxytag: member="string_utils::toUpper" ref="a4a692eb62e01ecc0757df7d2f53d3f36" args="(const std::string &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespacestring__utils.html#a4a692eb62e01ecc0757df7d2f53d3f36">string_utils::toUpper</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transforms all characters in the given string into upper case characters.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>String to transpose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the upper case only string </dd></dl>

</div>
</div>
<a class="anchor" id="a63713e559707c9cc927d62729fe424c9"></a><!-- doxytag: member="string_utils::trim" ref="a63713e559707c9cc927d62729fe424c9" args="(const std::string &amp;source, const std::string &amp;t=WHITESPACE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespacestring__utils.html#a63713e559707c9cc927d62729fe424c9">string_utils::trim</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code>WHITESPACE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Trims any occurence of each character given in parameter t from both ends (right and left side) of the given string.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>String to trim </td></tr>
    <tr><td class="paramname">t</td><td>String representing a set containg all trimmable characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the trimmed string </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a716c3d0cc1ab19bd56d1b2aa2a50662f"></a><!-- doxytag: member="string_utils::WHITESPACE" ref="a716c3d0cc1ab19bd56d1b2aa2a50662f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespacestring__utils.html#a716c3d0cc1ab19bd56d1b2aa2a50662f">string_utils::WHITESPACE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These characters are regarded as whitespaces. </p>
<p>We consider the following characters as whitespace:</p>
<ul>
<li><code>\r</code> carriage return</li>
<li><code>\n</code> newline</li>
<li><code>\t</code> tab</li>
<li><code>' '</code> space </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 11 2015 04:39:31 for hClustering by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
